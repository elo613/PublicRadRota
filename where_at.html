<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Registrar Weekly Rota</title>
    <link rel="stylesheet" href="where_at.css">
</head>
<body>
    <div class="container">
        <h1>Registrar Weekly Rota</h1>
        <div class="date-controls">
            <button onclick="rotaApp.changeWeek(-7)">← Previous Week</button>
            <div id="currentWeekRange">Loading...</div>
            <button onclick="rotaApp.changeWeek(7)">Next Week →</button>
            <button onclick="rotaApp.copyTable()">Copy Table</button>
        </div>
        <div id="rotaContainer">
            <div class="loading">Loading rota...</div>
        </div>
    </div>
    
    <script>
        class RotaApp {
            constructor() {
                this.currentMonday = this._getMondayOfWeek(new Date());
                this.DATA_SOURCES = {
                    registrars: './registrars_data.json',
                    rota: './rota.json',
                    blocks: './blocks.json',
                };
                this.CSS_STATUS_CLASSES = {
                    'Leave': 'status-leave',
                    'AAU Duty': 'status-duty',
                    'AAU Reporting': 'status-reporting',
                    'Ultrasound': 'status-ultrasound',
                    'Block': 'status-block',
                    'Mt Vernon Oncology': 'status-mt-vernon-oncology',
                    'WGH Reporting/Duty': 'status-wgh-reporting-duty',
                    'Additional': 'status-additional',
                    'None': 'status-none'
                };
                this.registrarsData = [];
                this.processedRota = new Map();
                this.processedBlocks = new Map();
            }

            async init() {
                try {
                    await this._loadAndProcessData();
                    this.render();
                } catch (e) {
                    console.error(e);
                    document.getElementById("rotaContainer").innerHTML = '<div class="error-message">Failed to load rota data. Please try again later.</div>';
                }
            }

            async _fetchData(url) {
                const res = await fetch(url);
                if (!res.ok) throw new Error(`Failed to fetch ${url}`);
                return res.json();
            }

            async _loadAndProcessData() {
                const [registrars, rota, blocks] = await Promise.all([
                    this._fetchData(this.DATA_SOURCES.registrars),
                    this._fetchData(this.DATA_SOURCES.rota),
                    this._fetchData(this.DATA_SOURCES.blocks)
                ]);
                this.registrarsData = registrars;
                this._processRotaData(rota);
                this._processBlocksData(registrars, blocks);
            }

            _processRotaData(data) {
                this.processedRota.clear();
                data.forEach(day => {
                    if (day.Date && day.Shifts) {
                        this.processedRota.set(day.Date, day.Shifts);
                    }
                });
            }

            _processBlocksData(registrars, blockDefs) {
                registrars.forEach(r => {
                    const blocks = [];
                    if (r.blocks) {
                        r.blocks.forEach(b => {
                            blocks.push({
                                start: new Date(b.start_date),
                                end: new Date(b.end_date),
                                blockName: b.block_name,
                                definition: blockDefs[b.block_name]
                            });
                        });
                    }
                    r.leave_records = r.leave_records?.map(l => ({
                        type: l.type,
                        start: new Date(l.start),
                        end: new Date(l.end)
                    })) || [];
                    this.processedBlocks.set(r.name, blocks);
                });
            }

            _normalizeDateToMidnight(d) {
                if (!d) return null;
                return new Date(d.getFullYear(), d.getMonth(), d.getDate());
            }

            _getAdditionalSessionStatus(registrarName, dateStr, session) {
                const dayShifts = this.processedRota.get(dateStr);
                if (dayShifts && dayShifts[session] && dayShifts[session].Additional) {
                    const additionalSessions = dayShifts[session].Additional;
                    for (const s of additionalSessions) {
                        // s is in the format [name, date, session, details]
                        if (s[0] === registrarName) {
                            return { text: `Other: ${s[3]}`, cssClass: this.CSS_STATUS_CLASSES.Additional };
                        }
                    }
                }
                return null;
            }

            _getShiftStatus(registrar, date, session) {
                const dateStr = date.toLocaleDateString('en-GB');
                const dayOfWeek = date.toDateString().split(' ')[0];
                const normalizedCurrentDate = this._normalizeDateToMidnight(date);

                // 1. Check for Leave (Highest priority)
                if (registrar.leave_records.some(l => {
                    const normalizedLeaveStart = this._normalizeDateToMidnight(l.start);
                    const normalizedLeaveEnd = this._normalizeDateToMidnight(l.end);
                    return normalizedCurrentDate >= normalizedLeaveStart && normalizedCurrentDate <= normalizedLeaveEnd;
                })) {
                    const leaveRecord = registrar.leave_records.find(l => {
                        const normalizedLeaveStart = this._normalizeDateToMidnight(l.start);
                        const normalizedLeaveEnd = this._normalizeDateToMidnight(l.end);
                        return normalizedCurrentDate >= normalizedLeaveStart && normalizedCurrentDate <= normalizedLeaveEnd;
                    });
                    return { text: `${leaveRecord.type} Leave`, cssClass: this.CSS_STATUS_CLASSES.Leave };
                }

                const dayShifts = this.processedRota.get(dateStr);
                if (dayShifts && dayShifts[session]) {
                    const shift = dayShifts[session];
                    
                    // 2. Check for AAU Duty/Reporting and Ultrasound
                    if (shift.Duty && shift.Duty.includes(registrar.name)) return { text: "AAU Duty", cssClass: this.CSS_STATUS_CLASSES["AAU Duty"] };
                    if (shift.Reporting && shift.Reporting.includes(registrar.name)) return { text: "AAU Reporting", cssClass: this.CSS_STATUS_CLASSES["AAU Reporting"] };
                    if (shift.Ultrasound && shift.Ultrasound.includes(registrar.name)) return { text: "Ultrasound Duty", cssClass: this.CSS_STATUS_CLASSES.Ultrasound };
                }
                
                // 3. Check for Manual Sessions
                const additionalSession = this._getAdditionalSessionStatus(registrar.name, dateStr, session);
                if (additionalSession) {
                    return additionalSession;
                }

                // 4. Check for Block rotations, only on weekdays
                if (date.getDay() !== 0 && date.getDay() !== 6) {
                    const blocks = this.processedBlocks.get(registrar.name);
                    if (blocks) {
                        for (const b of blocks) {
                            const normalizedBlockStart = this._normalizeDateToMidnight(b.start);
                            const normalizedBlockEnd = this._normalizeDateToMidnight(b.end);
                            if (normalizedCurrentDate >= normalizedBlockStart && normalizedCurrentDate <= normalizedBlockEnd) {
                                const val = b.definition?.[dayOfWeek]?.[session]?.value;
                                return {
                                    text: val || `Block: ${b.blockName}`,
                                    cssClass: this.CSS_STATUS_CLASSES[val] || this.CSS_STATUS_CLASSES.Block
                                };
                            }
                        }
                    }
                }
                
                // 5. Default to a 'None' status
                return { text: "-", cssClass: this.CSS_STATUS_CLASSES.None };
            }

            _getMondayOfWeek(date) {
                const d = new Date(date);
                const day = d.getDay();
                const diff = d.getDate() - day + (day === 0 ? -6 : 1);
                d.setDate(diff);
                d.setHours(0, 0, 0, 0);
                return d;
            }

            changeWeek(offsetDays) {
                this.currentMonday.setDate(this.currentMonday.getDate() + offsetDays);
                this.render();
            }

            render() {
                const week = [];
                for (let i = 0; i < 7; i++) {
                    const d = new Date(this.currentMonday);
                    d.setDate(d.getDate() + i);
                    week.push(d);
                }
                const currentWeekRange = `${week[0].toLocaleDateString('en-GB', {weekday: 'short', month: 'short', day: 'numeric', year: 'numeric'})} - ${week[6].toLocaleDateString('en-GB', {weekday: 'short', month: 'short', day: 'numeric', year: 'numeric'})}`;
                document.getElementById("currentWeekRange").textContent = currentWeekRange;

                let html = `<div class="table-container"><table id="rotaTable"><thead><tr><th>Registrar</th>`;
                week.forEach(d => {
                    html += `<th colspan="2">${d.toLocaleDateString('en-GB', {weekday: 'short', day: 'numeric', month: 'short'})}</th>`;
                });
                html += `</tr><tr><th></th>`;
                week.forEach(() => {
                    html += `<th>AM</th><th>PM</th>`;
                });
                html += `</tr></thead><tbody>`;

                this.registrarsData.forEach(r => {
                    html += `<tr><td>${r.name}</td>`;
                    week.forEach(d => {
                        ["AM", "PM"].forEach(s => {
                            const status = this._getShiftStatus(r, d, s);
                            html += `<td class="${status.cssClass}">${status.text}</td>`;
                        });
                    });
                    html += `</tr>`;
                });

                html += `</tbody></table></div>`;
                document.getElementById("rotaContainer").innerHTML = html;
            }

            async copyTable() {
                const table = document.getElementById('rotaTable');
                if (!table) {
                    alert('Rota table not found!');
                    return;
                }

                const range = document.createRange();
                range.selectNode(table);

                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                try {
                    const successful = document.execCommand('copy');
                    const msg = successful ? 'Table copied to clipboard!' : 'Failed to copy table.';
                    alert(msg);
                } catch (err) {
                    console.error('Error copying table: ', err);
                    alert('Failed to copy table. Your browser may not support this method.');
                } finally {
                    selection.removeAllRanges();
                }
            }
        }

        const rotaApp = new RotaApp();
        rotaApp.init();
    </script>
</body>
</html>
