<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Registrar Weekly Rota</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background: #f5f5f5;
        padding: 20px;
    }
    .container {
        max-width: 1400px;
        margin: 0 auto;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        padding: 20px;
    }
    h1 {
        text-align: center;
        margin-bottom: 15px;
        color: #2c3e50;
    }
    .date-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 15px;
        margin-bottom: 20px;
    }
    button {
        background: #34495e;
        border: none;
        color: white;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
    }
    button:hover {
        background: #4a5f7a;
    }
    #currentWeekRange {
        font-weight: bold;
        font-size: 1.2rem;
        min-width: 300px;
        text-align: center;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        table-layout: fixed; /* Ensures even column distribution */
    }
    thead tr {
        background: #34495e;
        color: white;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: center;
        font-size: 0.8rem;
        vertical-align: top; /* Ensure content starts at the top */
    }
    tbody tr:nth-child(even) {
        background: #f9f9f9;
    }
    .day-header {
        background: #5c7b9e;
        color: white;
        font-weight: bold;
        padding: 6px;
    }
    .session-header {
        font-size: 0.75rem;
    }
    .session-cell {
        min-height: 40px; /* Ensure consistent height for empty cells */
        display: flex;
        flex-direction: column; /* Stack multiple items vertically within the cell */
        align-items: stretch; /* Stretch items to fill horizontal space */
        justify-content: flex-start; /* Align items to the top if multiple */
        gap: 2px; /* Space between stacked shift items */
    }
    .shift-item {
        padding: 2px 4px;
        border-radius: 3px;
        white-space: nowrap; /* Prevent text wrapping within a shift item */
        overflow: hidden;
        text-overflow: ellipsis; /* Add ellipsis for overflow */
        display: block; /* Ensure it behaves as a block for stacking */
        text-align: center; /* Center text within the item */
    }
    /* Status-specific styling */
    .status-leave { background: #f8d7da; color: #721c24; font-weight: bold; }
    .status-duty { background: #d4edda; color: #155724; font-weight: bold; }
    .status-reporting { background: #fff3cd; color: #856404; font-weight: bold; }
    .status-block { background: #cce5ff; color: #004085; font-weight: bold; }
    .status-ultrasound { background: #d1ecf1; color: #0c5460; font-weight: bold; }
    .status-none { color: #6c757d; font-style: italic;} /* Style for '-' */
    /* Specific styles for identified block types if needed, matching the image */
    .status-mt-vernon-oncology { background: #e6f7ff; color: #0056b3; font-weight: bold; }
    .status-wgh-reporting-duty { background: #dff0d8; color: #3c763d; font-weight: bold; }

    .weekend-indicator {
        text-align: center;
        padding: 12px;
        background: #17a2b8;
        color: white;
        font-weight: bold;
        margin-bottom: 15px;
        border-radius: 6px;
    }
    .loading, .error-message {
        text-align: center;
        padding: 20px;
        font-size: 1.1rem;
        border-radius: 6px;
        margin: 20px 0;
    }
    .loading { color: #6c757d; }
    .error-message { background: #f8d7da; color: #721c24; }
</style>
</head>
<body>
<div class="container">
    <h1>Registrar Weekly Rota</h1>
    <div class="date-controls">
        <button onclick="rotaApp.changeWeek(-7)">← Previous Week</button>
        <div id="currentWeekRange"></div>
        <button onclick="rotaApp.changeWeek(7)">Next Week →</button>
    </div>
    <div id="rotaContainer">
        <div class="loading">Loading rota...</div>
    </div>
</div>

<script>
class RotaApp {
    constructor() {
        this.currentMonday = new Date(); // Stores the Monday of the currently displayed week
        this.registrarsData = []; // Array of registrar objects
        
        // Processed data structures for quick lookups
        this.processedRota = new Map(); // Map<dateStr (DD/MM/YYYY), Map<session, {duty: string, reporting: string}>>
        this.processedBlocks = new Map(); // Map<registrarName, Array<{start: Date, end: Date, blockName: string, definition: Object}>>
        this.processedUltrasound = new Map(); // Map<dateStr (DD/MM/YYYY), Map<session, Set<registrarName>>>

        // Configuration for data sources
        this.DATA_SOURCES = {
            registrars: './registrars_data.json',
            rota: './rota.json',
            blocks: './blocks.json',
            ultrasound: './ultrasound.json'
        };

        // CSS class mapping for various statuses/shift types
        this.CSS_STATUS_CLASSES = {
            'Leave': 'status-leave',
            'AAU Duty': 'status-duty',
            'AAU Reporting': 'status-reporting',
            'Ultrasound': 'status-ultrasound',
            'Block': 'status-block', // Generic block class
            'Mt Vernon Oncology': 'status-mt-vernon-oncology', // Specific block type from image
            'WGH Reporting/Duty': 'status-wgh-reporting-duty', // Specific block type from image
            'None': 'status-none'
        };
    }

    // --- Utility Date Functions ---
    _formatDateForDisplay(date) {
        return date.toLocaleDateString('en-US', {
            weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
        });
    }

    _formatDateForDataLookup(date) {
        const d = date.getDate().toString().padStart(2, '0');
        const m = (date.getMonth() + 1).toString().padStart(2, '0');
        const y = date.getFullYear();
        return `${d}/${m}/${y}`;
    }

    _parseLeaveBlockDate(dateStr) {
        const parts = dateStr.match(/(\d{1,2}) ([A-Za-z]{3}) (\d{4})/);
        if (parts) {
            const day = parseInt(parts[1], 10);
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = monthNames.indexOf(parts[2]);
            const year = parseInt(parts[3], 10);
            return new Date(Date.UTC(year, month, day)); // Parse as UTC
        }
        // Fallback for YYYY-MM-DD format, parsed as UTC
        const d = new Date(dateStr + 'T00:00:00Z');
        if (isNaN(d.getTime())) {
             console.warn(`Could not parse date: ${dateStr}. Falling back to local date interpretation, which might have timezone issues.`);
             return new Date(dateStr); // Fallback to local if UTC fails
        }
        return d;
    }

    _isDateBetween(checkDate, startDate, endDate) {
        const checkUTC = new Date(Date.UTC(checkDate.getFullYear(), checkDate.getMonth(), checkDate.getDate()));
        const endOfEndDate = new Date(endDate);
        endOfEndDate.setUTCHours(23, 59, 59, 999);
        return checkUTC >= startDate && checkUTC <= endOfEndDate;
    }

    _getMondayOfWeek(date) {
        const d = new Date(date);
        const dayOfWeek = d.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
        const diff = d.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
        d.setDate(diff);
        d.setHours(0, 0, 0, 0); // Normalize to start of day
        return d;
    }

    // --- Data Fetching and Processing ---
    async _fetchData(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Failed to load ${url}: ${response.statusText} (${response.status})`);
        }
        return await response.json();
    }

    async _loadAndProcessData() {
        try {
            const [registrars, rota, blocks, ultrasound] = await Promise.all([
                this._fetchData(this.DATA_SOURCES.registrars),
                this._fetchData(this.DATA_SOURCES.rota),
                this._fetchData(this.DATA_SOURCES.blocks),
                this._fetchData(this.DATA_SOURCES.ultrasound)
            ]);

            this.registrarsData = registrars;

            this._processRotaData(rota);
            this._processUltrasoundData(ultrasound);
            this._processBlocksData(registrars, blocks);

            console.log("Data loaded and processed successfully.");
        } catch (error) {
            document.getElementById('rotaContainer').innerHTML = `<div class="error-message">Failed to load rota data: ${error.message}. Please check data files.</div>`;
            console.error("Error during data loading or processing:", error);
            throw error;
        }
    }

    _processRotaData(rotaRaw) {
        this.processedRota.clear();
        rotaRaw.forEach(dayEntry => {
            if (dayEntry.Date && dayEntry.Shifts) {
                this.processedRota.set(dayEntry.Date, dayEntry.Shifts);
            }
        });
        console.log("Processed Rota Data:", this.processedRota);
    }

    _processUltrasoundData(ultrasoundRaw) {
        this.processedUltrasound.clear();
        ultrasoundRaw.forEach(entry => {
            if (entry.Date && entry.Session && entry['Registrar name']) {
                if (!this.processedUltrasound.has(entry.Date)) {
                    this.processedUltrasound.set(entry.Date, new Map());
                }
                const sessionsMap = this.processedUltrasound.get(entry.Date);
                if (!sessionsMap.has(entry.Session)) {
                    sessionsMap.set(entry.Session, new Set());
                }
                sessionsMap.get(entry.Session).add(entry['Registrar name']);
            }
        });
        console.log("Processed Ultrasound Data:", this.processedUltrasound);
    }

    _processBlocksData(registrars, blocksMapRaw) {
        this.processedBlocks.clear();
        registrars.forEach(registrar => {
            const registrarBlocks = [];
            if (registrar.blocks) {
                registrar.blocks.forEach(blockRef => {
                    const blockDefinition = blocksMapRaw[blockRef.block_name];
                    if (blockDefinition) {
                        registrarBlocks.push({
                            start: this._parseLeaveBlockDate(blockRef.start_date),
                            end: this._parseLeaveBlockDate(blockRef.end_date),
                            blockName: blockRef.block_name,
                            definition: blockDefinition
                        });
                    } else {
                        console.warn(`Block definition for "${blockRef.block_name}" not found for registrar ${registrar.name}.`);
                    }
                });
            }
            this.processedBlocks.set(registrar.name, registrarBlocks);

            if (registrar.leave_records) {
                registrar.leave_records = registrar.leave_records.map(leave => ({
                    type: leave.type,
                    start: this._parseLeaveBlockDate(leave.start),
                    end: this._parseLeaveBlockDate(leave.end)
                }));
            }
        });
        console.log("Processed Blocks Data:", this.processedBlocks);
    }

    // --- Shift Status Logic ---
    _getShiftStatuses(registrar, date, session) {
        const dateForRotaLookup = this._formatDateForDataLookup(date);
        const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
        const isWeekend = (dayOfWeek === 0 || dayOfWeek === 6);
        const statuses = [];

        // 1. Check Leave (Highest Priority and Exclusive)
        if (registrar.leave_records) {
            for (const leave of registrar.leave_records) {
                if (this._isDateBetween(date, leave.start, leave.end)) {
                    console.log(`[${registrar.name}] ${dateForRotaLookup} ${session}: Found Leave: ${leave.type}`);
                    return [{ text: `${leave.type} Leave`, cssClass: this.CSS_STATUS_CLASSES.Leave }];
                }
            }
        }

        // 2. Check Rota (Duty/Reporting)
        const dayShifts = this.processedRota.get(dateForRotaLookup);
        if (dayShifts && dayShifts[session]) {
            const shiftDetails = dayShifts[session];
            if (shiftDetails.Duty === registrar.name) {
                statuses.push({ text: "AAU Duty", cssClass: this.CSS_STATUS_CLASSES['AAU Duty'] });
                console.log(`[${registrar.name}] ${dateForRotaLookup} ${session}: Found Rota Duty: AAU Duty`);
            }
            if (shiftDetails.Reporting === registrar.name) {
                statuses.push({ text: "AAU Reporting", cssClass: this.CSS_STATUS_CLASSES['AAU Reporting'] });
                console.log(`[${registrar.name}] ${dateForRotaLookup} ${session}: Found Rota Reporting: AAU Reporting`);
            }
        }

        // 3. Check Ultrasound
        const ultrasoundForDay = this.processedUltrasound.get(dateForRotaLookup);
        if (ultrasoundForDay && ultrasoundForDay.get(session)?.has(registrar.name)) {
            statuses.push({ text: "Ultrasound", cssClass: this.CSS_STATUS_CLASSES.Ultrasound });
            console.log(`[${registrar.name}] ${dateForRotaLookup} ${session}: Found Ultrasound`);
        }

        // 4. Check Blocks (only for weekdays unless explicitly defined for weekends)
        const registrarBlocks = this.processedBlocks.get(registrar.name);
        if (registrarBlocks) {
            for (const block of registrarBlocks) {
                if (this._isDateBetween(date, block.start, block.end)) {
                    const dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][dayOfWeek];
                    const blockValue = block.definition?.[dayName]?.[session]?.value;

                    // Only add block if it has a specific value for this day/session OR it's a weekday and no other shifts were found yet.
                    // For weekends, we only show explicit AAU or Ultrasound, not generic blocks.
                    if (blockValue) {
                        const blockClass = this.CSS_STATUS_CLASSES[blockValue] || this.CSS_STATUS_CLASSES.Block;
                        statuses.push({ text: blockValue, cssClass: blockClass });
                        console.log(`[${registrar.name}] ${dateForRotaLookup} ${session}: Found Block (specific): ${blockValue}`);
                    } else if (!isWeekend && statuses.length === 0) { // If no specific value, and no other shifts, and it's a weekday
                        statuses.push({ text: `Block: ${block.blockName}`, cssClass: this.CSS_STATUS_CLASSES.Block });
                        console.log(`[${registrar.name}] ${dateForRotaLookup} ${session}: Found Block (generic): ${block.blockName}`);
                    }
                }
            }
        }
        
        // If no specific status found and not on leave, return a default 'None' status
        if (statuses.length === 0) {
            console.log(`[${registrar.name}] ${dateForRotaLookup} ${session}: No shifts found. Returning '-'`);
            return [{ text: "-", cssClass: this.CSS_STATUS_CLASSES.None }];
        }

        // Remove duplicates and sort for consistent display
        const uniqueStatuses = Array.from(new Set(statuses.map(s => JSON.stringify(s)))).map(s => JSON.parse(s));
        return uniqueStatuses.sort((a, b) => a.text.localeCompare(b.text));
    }

    // --- Rendering Logic ---
    _renderRotaTable() {
        const rotaContainer = document.getElementById('rotaContainer');
        const currentWeekRangeElem = document.getElementById('currentWeekRange');

        let weekDates = [];
        const startOfWeek = new Date(this.currentMonday);
        for (let i = 0; i < 7; i++) {
            const date = new Date(startOfWeek);
            date.setDate(startOfWeek.getDate() + i);
            weekDates.push(date);
        }

        currentWeekRangeElem.textContent = `${this._formatDateForDisplay(weekDates[0])} - ${this._formatDateForDisplay(weekDates[6])}`;

        let html = '';
        const hasWeekend = weekDates.some(date => date.getDay() === 0 || date.getDay() === 6);
        if (hasWeekend) {
            html += `<div class="weekend-indicator">Weekend Schedule: Only AAU duty/reporting and explicit Ultrasound shown; otherwise '-'</div>`;
        }

        html += `<table>
            <thead>
                <tr>
                    <th rowspan="2">Registrar</th>`;
        weekDates.forEach(date => {
            const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
            const dateNum = date.getDate().toString().padStart(2, '0');
            const monthName = date.toLocaleDateString('en-US', { month: 'short' });
            html += `<th colspan="2" class="day-header">${dayName}<br>${dateNum} ${monthName}</th>`;
        });
        html += `</tr>
                <tr>`;
        for (let i = 0; i < 7; i++) {
            html += `<th class="session-header">AM</th><th class="session-header">PM</th>`;
        }
        html += `</tr>
            </thead>
            <tbody>`;

        this.registrarsData.forEach(registrar => {
            html += `<tr>
                <td>${registrar.name}</td>`;
            weekDates.forEach(date => {
                const amStatuses = this._getShiftStatuses(registrar, date, "AM");
                const pmStatuses = this._getShiftStatuses(registrar, date, "PM");
                
                // AM Cell
                html += `<td class="session-cell">`;
                if (amStatuses.length > 0) {
                    amStatuses.forEach(status => {
                        html += `<div class="shift-item ${status.cssClass}">${status.text}</div>`;
                    });
                } else {
                    html += `<div class="shift-item ${this.CSS_STATUS_CLASSES.None}">-</div>`;
                }
                html += `</td>`;

                // PM Cell
                html += `<td class="session-cell">`;
                if (pmStatuses.length > 0) {
                    pmStatuses.forEach(status => {
                        html += `<div class="shift-item ${status.cssClass}">${status.text}</div>`;
                    });
                } else {
                    html += `<div class="shift-item ${this.CSS_STATUS_CLASSES.None}">-</div>`;
                }
                html += `</td>`;
            });
            html += `</tr>`;
        });

        html += `</tbody></table>`;
        rotaContainer.innerHTML = html;
    }

    // --- Public Methods (called by event handlers) ---
    async initializeApp() {
        document.getElementById('rotaContainer').innerHTML = `<div class="loading">Loading rota...</div>`;
        try {
            await this._loadAndProcessData();
            // IMPORTANT: Set the initial week to the week of the image provided (July 7, 2025)
            // This ensures we're looking at the same week for debugging.
            const july7_2025 = new Date('2025-07-07T00:00:00Z'); // UTC date for consistency
            this.currentMonday = this._getMondayOfWeek(july7_2025); 
            this._renderRotaTable();
        } catch (error) {
            // Error message already handled and displayed by _loadAndProcessData
        }
    }

    changeWeek(days) {
        this.currentMonday.setDate(this.currentMonday.getDate() + days);
        this._renderRotaTable();
    }
}

const rotaApp = new RotaApp();
window.addEventListener('DOMContentLoaded', () => rotaApp.initializeApp());
</script>
</body>
</html>
